#########################Shared Data Structure
import threading
from collections import defaultdict, deque

# Shared resources
message_queue = deque()  # Global message queue
received_messages = defaultdict(deque)  # Buffers for each agent

# Lock for synchronization
queue_lock = threading.Lock()

######################Agent Implementation
python
Copy
Edit
import threading
import time

class Agent:
    def __init__(self, name):
        self.name = name

    def send_message(self, recipient, content):
        with queue_lock:
            message = {"sender": self.name, "recipient": recipient, "content": content}
            message_queue.append(message)
            print(f"[{self.name}] Sent message to {recipient}: {content}")

    def receive_messages(self):
        while True:
            time.sleep(1)  # Poll for messages
            with queue_lock:
                while received_messages[self.name]:
                    message = received_messages[self.name].popleft()
                    print(f"[{self.name}] Received: {message}")

# Example usage
if __name__ == "__main__":
    agent = Agent("Agent1")
    threading.Thread(target=agent.receive_messages, daemon=True).start()
    agent.send_message("Agent2", "Hello!")


##################################Communication Leader
python
Copy
Edit
class CommunicationLeader:
    def run(self):
        while True:
            time.sleep(1)  # Simulate work cycle
            with queue_lock:
                while message_queue:
                    message = message_queue.popleft()
                    recipient = message["recipient"]
                    received_messages[recipient].append(message)
                    print(f"[Leader] Routed message from {message['sender']} to {recipient}: {message['content']}")

# Example usage
if __name__ == "__main__":
    leader = CommunicationLeader()
    threading.Thread(target=leader.run, daemon=True).start()